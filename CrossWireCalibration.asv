function varargout = CrossWireCalibration(varargin)
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @CrossWireCalibration_OpeningFcn, ...
                   'gui_OutputFcn',  @CrossWireCalibration_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before CrossWireCalibration is made visible.
function CrossWireCalibration_OpeningFcn(hObject, eventdata, handles, varargin)
global fLoaded
handles.output = hObject; % Choose default command line output for CrossWireCalibration
guidata(hObject, handles); % Update handles structure
addpath(genpath('D:\nav\libs\matlab')); % add libraries
fLoaded = false;


% --- Outputs from this function are returned to the command line.
function varargout = CrossWireCalibration_OutputFcn(hObject, eventdata, handles) 
varargout{1} = handles.output;% Get default command line output from handles structure


% --- Executes on button press in btnPrev.
function btnPrev_Callback(hObject, eventdata, handles)
moveFrame('prev');
guiUpdate(handles);

function btnNext_Callback(hObject, eventdata, handles)
moveFrame('next');
guiUpdate(handles);

function btnLoadFile_Callback(hObject, eventdata, handles)                  
global iFrame nFrames Hws I linSpace fLoaded mark1 mark2 mark3
fpath = 'D:\data\AmfiTrackCalibration';
loadFile(fpath);
guiUpdate(handles);


% --- Executes on button press in btnSave.
function btnSave_Callback(hObject, eventdata, handles)
saveMarkers()

% --- Executes on button press in btnMark1.
function btnMark1_Callback(hObject, eventdata, handles)
putMarker(1, handles);
guiUpdate(handles);



% --- Executes on button press in btnUnmark.
function btnUnmark_Callback(hObject, eventdata, handles)
removeAllMarkers();
guiUpdate(handles);

% --- Executes on button press in btnMark2.
function btnMark2_Callback(hObject, eventdata, handles)
putMarker(2, handles);
guiUpdate(handles);

% --- Executes on button press in btnMark3.
function btnMark3_Callback(hObject, eventdata, handles)
putMarker(3, handles);
guiUpdate(handles);

% --- Executes on button press in btnCalib.
function btnCalib_Callback(hObject, eventdata, handles)
% hObject    handle to btnCalib (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --- Executes on button press in btnShowAllPlanes3D.
function btnShowAllPlanes3D_Callback(hObject, eventdata, handles)
showAllPlanes();

% --- Executes on button press in btnShowAllPoints3D.
function btnShowAllPoints3D_Callback(hObject, eventdata, handles)
showAllPoints();

%------------Application functions-----------------------------------------
function guiUpdate(handles)
    global iFrame nFrames I mark1 mark2 mark3 linSpace
    if nFrames == 0,    return; end;
    axes(handles.axesFrame);
    %colormap(gray);
    imagesc(linSpace.y, linSpace.x, I(:,:,iFrame));
    hold on
    plot(mark1(2,iFrame), mark1(1,iFrame), '*g');
    plot(mark2(2,iFrame), mark2(1,iFrame),  '*y');
    plot(mark3(2,iFrame), mark3(1,iFrame),  '*r');
    hold off
    xlabel('y (m)'); ylabel('x (m)'); 
    str = sprintf('frame %d of %d', iFrame, nFrames);
    set(handles.txtFrames,'string', str);

function moveFrame(strDirection)
    global iFrame nFrames
    if nFrames == 0,    return; end;
    if strcmp(strDirection, 'next')
        iFrame = iFrame+1;
        if iFrame>nFrames, iFrame = 1; end;
    end
    if strcmp(strDirection, 'prev')
        iFrame = iFrame-1;
        if iFrame == 0, iFrame = nFrames; end;
    end

function loadFile(filePath)
    global iFrame nFrames Hws I linSpace mark1 mark2 mark3 fpath
    fpath = filePath;
    [ Hws, I, nFrames ] = loadData(fpath);
    if nFrames == 0, return; end;
    [ nSamples, nElements ] = size(I(:,:,1));
    [ gridx, gridy, ~] = linearArrayGridMsensor(0.1953e-3, nElements, 7.813e+6, 1540, nSamples); 
    linSpace.x = gridx(1:nSamples, 1);
    linSpace.y = gridy(1,1:nElements);

    fullFileName = [ fpath, '\', 'MARK','.mat' ];
    if exist(fullFileName, 'file') == 2
        load(fullFileName);
        mark1 = MARK{1};
        mark2 = MARK{2};
        mark3 = MARK{3};
        clear('MARK');
    else
        mark1 = ones(4,nFrames)*NaN;
        mark2 = ones(4,nFrames)*NaN;
        mark3 = ones(4,nFrames)*NaN;
    end
    iFrame = 1;
    
function putMarker(mark, handles)
    global mark1 mark2 mark3 iFrame nFrames
    if mark<1 && mark>3,        return; end;
    if nFrames == 0,            return; end;
    [x y] = getpts(handles.axesFrame);
    p = [ y(1) x(1) 0 1]'; 
    switch mark
        case 1
            mark1(:,iFrame) = p;
        case 2
            mark2(:,iFrame) = p;
        case 3
            mark3(:,iFrame) = p;
    end
    
function removeAllMarkers()
    global mark1 mark2 mark3 iFrame nFrames
    if nFrames == 0,    return; end;
    mark1(:,iFrame) = ones(4,1)*NaN;
    mark2(:,iFrame) = ones(4,1)*NaN;
    mark3(:,iFrame) = ones(4,1)*NaN;
    
function saveMarkers
    global fpath mark1 mark2 mark3 nFrames
    if nFrames == 0, return; end;
    MARK = cell(3);
    MARK{1} = mark1;
    MARK{2} = mark2;
    MARK{3} = mark3;
    fullFileName = [ fpath, '\', 'MARK','.mat' ];
    save(fullFileName,'-v7.3', 'MARK');
    
function showAllPoints()
    global Hws mark1 mark2 mark3 nFrames
    if nFrames == 0, return; end;
    p1 = ones(4,nFrames);
    p2 = ones(4,nFrames);
    p3 = ones(4,nFrames);
    for i = 1:nFrames
        p1(:,i) = Hws(:,:,i)*mark1(:,i);
        p2(:,i) = Hws(:,:,i)*mark2(:,i);
        p3(:,i) = Hws(:,:,i)*mark3(:,i);
    end
    figure();
    subplot(2,2,1); plot3(p1(1,:), p1(2,:), p1(3,:), '*g', p2(1,:), p2(2,:), p2(3,:), '*y', p3(1,:), p3(2,:), p3(3,:), '*r'); xlabel('x(m)'); ylabel('y(m)'); zlabel('z(m)'); grid on; 
    subplot(2,2,2); plot(p1(1,:), p1(2,:), '*g', p2(1,:), p2(2,:), '*y', p3(1,:), p3(2,:), '*r'); xlabel('x(m)'); ylabel('y(m)'); grid on;
    subplot(2,2,3); plot(p1(1,:), p1(3,:), '*g', p2(1,:), p2(3,:), '*y', p3(1,:), p3(3,:), '*r'); xlabel('x(m)'); ylabel('z(m)'); grid on;
    subplot(2,2,4); plot(p1(2,:), p1(3,:), '*g', p2(2,:), p2(3,:), '*y', p3(2,:), p3(3,:), '*r'); xlabel('y(m)'); ylabel('z(m)'); grid on;
    
function showAllPlanes()
        global I Hws mark1 mark2 mark3 nFrames linSpace
        if nFrames == 0, return; end;
        p1 = ones(4,nFrames);
        p2 = ones(4,nFrames);
        p3 = ones(4,nFrames);
        w = max(linSpace.x) - min(linSpace.x);
        h = max(linSpace.y) - min(linSpace.y);
        T = eye(4); T(4,1) = w/2;
        R = getRotationMetrix(0,0,-90);
        Hcorr = T*R;
        figure();
        
        showImageInSpace(I(:,:,1), w, h, Hws(:,:,1));
        hold on
        for i = 1:nFrames
            p1 = Hws(:,:,i)*mark1(:,i);
            p2 = Hws(:,:,i)*mark2(:,i);
            p3 = Hws(:,:,i)*mark3(:,i);
            showImageInSpace(I(:,:,i), w, h, Hws(:,:,i)*Hcorr);
            plot3(p1(1), p1(2),p1(3),'*g', p2(1),p2(2),p2(3),'*y', p3(1), p3(2),p3(3),'*r');
        end
        hold off
        grid on
